<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Minesweeper</title>

<style>

    .hidden{
	    display: none;
    }
    /*****
    #display > div {
        border: 1px solid lightblue;
        clear: left;
        margin: 5px;
    }

    #display > div > div{
        width: 50px;
        float: left;
    }
    *****/

    .row {
        clear:left;
    }

    .cell {
        float: left;
        width: 40px;
        height: 40px;
        background-color: lightblue;
        margin: 4px;
        border-radius: 5px;
    }

    .unopened {
        cursor: pointer;
        box-shadow: 0px 6px 0 0 darkblue;
    }

    .unopened :hover {
    
    }

    .unopened :active {
        
    }


</style>


</head>

<body>

<div id="display"></div>

<div id="start">

</div><!-- start -->

<div id="main">
	<div id="header">

	</div>
	<div id="board"></div>
</div><!-- main -->

<div id="settings">

</div><!-- settings -->

<div id="difficulty">

</div><!-- difficulty -->

<div id="scoreboard">

</div><!-- scoreboard -->


<script defer>

var game = (function () {

    var status = {
        FLAG_OVERFLOW: 'No more flags to plant.',
        EXPLODED: 'Bomb triggered.',
        OK: 'Ok',
        WIN: 'Win'
    };

    var field = (function () {
        var cells = [],
            bombCells = [],
            flags = [],
            dimension = {rows:0, columns:0};


        function surroundingCells(row, col) {
            var cells = [];

            if (isValidIndex(row - 1    , col - 1)) cells.push(cellAt(row - 1   , col - 1));
            if (isValidIndex(row        , col - 1)) cells.push(cellAt(row       , col - 1));
            if (isValidIndex(row + 1    , col - 1)) cells.push(cellAt(row + 1   , col - 1));
            if (isValidIndex(row - 1    , col))     cells.push(cellAt(row - 1   , col));
            if (isValidIndex(row + 1    , col))     cells.push(cellAt(row + 1   , col));
            if (isValidIndex(row - 1    , col + 1)) cells.push(cellAt(row - 1   , col + 1));
            if (isValidIndex(row        , col + 1)) cells.push(cellAt(row       , col + 1));
            if (isValidIndex(row + 1    , col + 1)) cells.push(cellAt(row + 1   , col + 1));

            return cells;
        }

        function isValidIndex(row, col) {
            return row >= 0 && col >= 0 && row < dimension.rows && col < dimension.columns;
        }


        function explodeBombs() {
            var cells = [], i, c;

            // cells with unflagged bombs
            for (i = 0, c = bombCells.length; i < c; i++) {
                if (bombCells[i].flag !== true) {
                    bombCells[i].opened = true;
                    cells.push(bombCells[i]);
                } 
            }

            // flagged cells with no bombs
            for (i = 0, c = flags.length; i < c; i++) {
                if (flags[i].flag && !flags[i].bomb) cells.push(flags[i]);
            }

            return {
                status: game.status.EXPLODED,
                cells: cells
            };
        }

        function blank(row, col) {
            var current = cellAt(row, col);
            var cells = [], blanks = [];
            

            cells.push(current);
            blanks.push(current);

            var end = blanks.length, scs = [];

            for (var i = 0; i < end; i++) {

                blanks[i].opened = true;
                scs = surroundingCells(blanks[i].row, blanks[i].col);

                for (var j = 0, c = scs.length; j < c; j++){

                    if( ! scs[j].opened){

                        scs[j].opened = true;
                        cells.push(scs[j]);

                        if(scs[j].hint === 0){
                            blanks.push(scs[j]);
                            end = blanks.length;
                        }
                    }
                }
            }

            return {
                status: game.status.OK,
                cells: cells
            };
        }

        function hintCell(cell) {
            cell.opened = true;
            return {
                status: game.status.OK,
                cells: [cell]
            };
        }

        // returns list of affected cells
        function click(row, col) {
            var cell = cellAt(row, col);

            if (cell.bomb) return explodeBombs();
            if (cell.hint > 0) return hintCell(cell);
            return blank(row, col);
        }

        
        function setFlag(row, col) {
            if (bombCells.length <= flags.length) return {
                status: game.status.FLAG_OVERFLOW,
                cells:[]
            };

            var cell = cellAt(row, col);
            cell.flag = true;
            return isDone();
        }

        function isDone() {
            for (var i = 0, c = bombCells.length; i < c; i++) {
                if (bombCells[i].bomb === true && bombCells[i].flag === false) return {status: game.status.OK, cells:[]};
            }

            return {
                status: game.status.WIN,
                cells:[]
            }
        }

        function updateHint(row, col) {
            var scs = surroundingCells(row, col);
            var bombCount = 0;

            for (var i = 0, c = scs.length; i < c; i++)
                if (scs[i].bomb) bombCount++;

            cellAt(row, col).hint = bombCount;
        }

        function cellAt(row, col) {
            return cells[row * dimension.columns + col];
        }

        function initField(rowCount, colCount) {

            cells.length = 0;

            var i = 0;
            for (var ri = 0; ri < rowCount; ri++)
                for (var ci = 0; ci < colCount; ci++) {
                    cells[i++] = {
                        row: ri,
                        col: ci,
                        bomb: false,
                        flag: false,
                        hint: 0,
                        opened: false
                    };
                }

            dimension.rows = rowCount;
            dimension.columns = colCount;
        }

        // Returns a random integer between min (included) and max (excluded)
        // Using Math.round() will give you a non-uniform distribution!
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }

        function initBombs(bombCount) {
            var selected = [], index = 0, c = cells.length;
            var i = bombCount - 1;

            while (i >= 0) {
                index = getRandomInt(0, c);
                if (selected.indexOf(index) === -1) {
                    selected.push(index);
                    cells[index].bomb = true;
                    bombCells.push(cells[index]);
                    updateSurroundingHints(cells[index].row, cells[index].col);
                    i--;
                }

            }
        }

        function updateSurroundingHints(row, col) {
            var scs = surroundingCells(row, col);
            for (var i = 0, c = scs.length; i < c; i++) {
                updateHint(scs[i].row, scs[i].col);
            }
        }

        function init(rowCount, colCount, bombCount) {
            initField(rowCount, colCount);
            initBombs(bombCount);
        }

        return {
            init: init,
            setFlag: setFlag,
            click: click,
            cells: cells,
            cellAt: cellAt,
            dimension: dimension
        };
    })();

    return {
        field: field,
        STATUS: status
    }
})();/** game **/

var ui = (function (d) {
    return {

        start: (function (el) {

            return {

            }
        })(d.getElementById('start'))/** start **/,

        display: (function (el) {

            function showField() {
                var f = game.field,
                    d = '';

                for (var r = 0, rc = f.dimension.rows; r < rc; r++) {
                    d += '<div class="row">';
                    for (var c = 0, cc = f.dimension.columns; c < cc; c++) {
                        var cell = game.field.cellAt(r, c);
                        d += '<div class="cell unopened">';

                        d += '<div>' + cell.row + ', ' + cell.col + '</div>';
                        
                        d += cell.bomb === true ? '<div>bomb</div>' : '<div>&nbsp;</div>';
                        d += '<div> hint: ' + cell.hint + '</div>';

                        d += '</div>';
                    }
                    d += '</div>';
                }

                el.innerHTML = d;

            }

            return {
                showField: showField
            }
        })(d.getElementById('display'))/** display **/,

        main: (function (el) {

            return {

            }
        })(d.getElementById('main'))/** main **/,

        settings: (function (el) {

            return {

            }
        })(d.getElementById('settings'))/** settings **/,

        difficulty: (function (el) {

            return {

            }
        })(d.getElementById('difficulty'))/** difficulty **/,

        scoreboard: (function (el) {

            return {

            }
        })(d.getElementById('scoreboard'))/** scoreboard **/

    }
})(document);/** ui **/

(function () {
    game.field.init(5, 4, 8);
    ui.display.showField();
})();

</script>


</body>
</html>
